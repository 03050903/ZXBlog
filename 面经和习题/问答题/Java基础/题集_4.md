## 一、重载和重写的区别

重载:

* 发生在同一个类中，**方法名必须相同，参数类型不同、个数不同、顺序不同**，方法返回值和访问修饰符可以不同，发生在编译时。

重写:

* 发生在父子类中，方法名、参数列表必须相同，**返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类**；如果父类方法访问修饰符为private，则子类就不能重写该方法。

## 二、String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的

简单的来说：String 类中使用 final 关键字字符数组保存字符串，`private final char value[]`，所以 String 对象是不可变的。而 StringBuilder 与StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[]value **但是没有用 final 关键字修饰**，所以
这两种对象都是可变的。

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;
    /**
     * This no-arg constructor is necessary for serialization of subclasses.
     */
    AbstractStringBuilder() {
    }
}
```

线程安全性String 中的对象是不可变的，也就可以理解为常量，线程安全。

AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、 append、 insert、 indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全
的。
性能 : **每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的String 对象**。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

对于三者使用的总结：

1. 操作少量的数据 = String
2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer

## 三、在一个静态方法内调用一个非静态成员为什么是非法的

当New 一个对象的时候，并不是先在堆中为对象开辟内存空间，而是先将类中的静态方法（带有static修饰的静态函数）的代码加载到一个叫做方法区的地方，然后 再在堆内存中创建对象。

**所以说静态方法会随着类的加载而被加载**。当你new一个对象时，该对象存在于对内存中，this关键字一般指该对象，但是如果没有 new对象，而是通过类名调用该类的静态方法也可以。

静态方法是属于类的，动态方法属于实例对象，在类加载的时候就会分配内存，可以 通过类名直接去访问，非静态成员（变量和方法）属于类的对象，所以只有在对象实例化之后才存在，然后通过类的对象去访问。

**在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错**。

## 四、在 Java 中定义一个不做事且没有参数的构造方法的作用

Java 程序在执行子类的构造方法之前，如果没有用 `super()` 来调用父类特定的构造方法，则会调用父类中“ 没有参数的构造方法” 。

因此，**如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误**，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。

解决办法是在父类里加上一个不做事且没有参数的构造方法。

## 五、成员变量和局部变量的区别

(1)、从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；

成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；

但是，成员变量和局部变量都能被 final 所修饰；

(2)、从变量在内存中的存储方式来看，成员变量是对象的一部分，**而对象存在于堆内存，局部变量存在于栈内存**。

(3)、**从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在**，而局部变量随着方法的调用而自动消失。

(4)、成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。

## 六、对象实体与对象引用有何不同?

new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）; 

一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）

## 七、对象的相等与指向他们的引用相等，两者有什么不同？

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

## 八、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?

帮助子类做初始化工作。